三种遍历方法，递归法其实很简单，只需要定义好跳出条件（为null）然后调整输出位置即可

这里主要介绍迭代法。迭代遍历树的一般思路就是根据遍历顺序对栈进行操作

1.preorder.在前序遍历的过程中，遍历顺序为：root->left->right
所以可以想到的是，遍历到的当前节点肯定是不用入栈的，而观察到right节点
是在最后，所以是需要保存的，举个例子：
				 a
				/ \
			  b     c
			 / \   / \
			d   e  f  g
c为a的右孩子，e为b的左孩子，而按照顺序，一定是先遍历完a的左边再遍历其右边，
所以根据栈后进先出的规则，需要先把c压栈，然后e在栈中一定是高于c的。处理完
右节点后，就可以直接把迭代器迭代到下一个左节点上了。
总的过程大概如下：
  i.定义迭代器p
  ii.若p为null,则p=stack.pop(),并直接输出
  iii.判断p.right是否为空，不为空则压栈
  iv.p=p.left
  v.重复ii-iv,直到stack和p都为空。
  iv.重复i
  
2.postorder.在后序遍历这里，有一个问题我想了很久，就是，如果每次把根节点
压栈，那么怎么保证他的左右孩子已经被遍历过？以上面为例，如果一开始将a压栈，当
遍历完b或c后，又到了a，那么怎么知道之前遍历过bc?后面看了网上的解答，发现这里
对list的使用很巧妙，根据规则，后续遍历根节点一定是最后遍历到的，那么就可以不用
让根节点留在stack的栈底，而是保存在res的最后一位，而每次出栈的时候都采用add(0,p)
进行添加。

3.inorder.中序遍历。根据left-root-right的规则，可以想到的是每次必须从
最左边开始，在上面的例子中，就是从d开始遍历，那么由此可得到第一步：对左孩子不
断进行压栈操作。按照规则，遍历完左子树，需要遍历root,于是可以想到第二步:直接
pop一个作为根节点，存入res。最后遍历右子树：p = p.right。

总的来说，二叉树的三序遍历思路都不算难，都是按照他们基本的遍历顺序进行压栈处理的，
只是在进行栈操作的时候有很多小细节需要注意，否则就很难跳出循环。（比如说我。。。）
  