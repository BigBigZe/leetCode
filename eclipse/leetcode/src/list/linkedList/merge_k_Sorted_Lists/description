Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

Solution:
	结合网上的思路以及我自己的解题方法，总结一下大致有三种：
	1.暴力法。
	直接使用Util工具类把所有链表放在List中，再用Collections进行排序，最后再进行重新连接。
	！！！思路最清晰也最容易实现，但是效率最低，时间复杂度是O(lgN*N*M)其中N为list数组大小，
	M为这里面的链表平均长度，主要是由排序决定的。
	
	2.空间换时间。
	这还是我的一贯做法，基本思路大致为：
	首先以节点为单位把所有链表依次遍历一遍，采用map记录其值和引用，这里采用了两个map，目的是将
	值一样的节点连接在一起，比如有三个1->1->1，那么头和尾将分别记录在两个map中；然后再把key
	按照从小到大的顺序进行排序，这里的方法和暴力法的做法一样；最后把排好序的关键字依次头尾相连。
	！！！这里比暴力法快的地方在于：1.排序的数量更少2.排完序后并不需要逐个遍历，而是直接可以拿到
	头尾节点进行操作。时间复杂度比法1稍微低一点，主要是需要排序的东西更少。
	20ms
	
	3.分治。
	把整个数组不断二分成单个链表，然后转化为两个排序链表的合并问题，最后不断归并。
	！！！这个总的时间复杂度算法和归并排序类似。事实上也就是方法1，但是为什么比前两者快了几倍？
	因为少了第一步遍历所有节点，以及最后一步把所有节点连接起来，事实上怎个过程都没有产生任何
	时间浪费，即插入的同时已经完成了排序。
	