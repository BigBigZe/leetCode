给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

```

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

子问题输出：[1,2,4,3,5,7,6,8,9]
```

解释:
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)
 

说明:

给定矩阵中的元素总数不会超过 100000 。

Solution：

这道题用时：1个上午加1个中午加下午1个小时，基本上是死磕出来的

先说原问题，经过我几个小时的死磕，最后得出的结论就是这种二维数组的乱七八糟遍历一定要动手写。
写什么呢?按照它的规则写出相应的坐标，比如上面的用例是按以下规律遍历的(大括号表示在同一斜行)：
- [0,0] 
- {[0,1][1,0]} 
- {[2,0][1,1][0,2]} 
- {[1,2][2,1]}
- {[2][2]}

可以想象成一个质点从[0][0]开始按照图中的轨迹连续前进，质点某一时刻的坐标为[x,y]，而前进有四种情况：
- 在斜行内向右上方行进。这种情况下可以发现质点的运动规律为：x(next) = x-1,y(next) = y+1。这个规律由图中的运动轨迹可以看出来。
- 在斜行内向左下方行进。同理这种情况下运动规律为：x(next) = x+1,y(next) = y-1。
- 由右上方方向换成向左下方行进。这种情况可以看[0,0]->[0,1]，由于上一步的方向仍然会是右上方，因此[0,0]理论上的下一步是[-1，1]，而做完这一步之后，我们需要判定x是否越界了，如果越界，则让他恢复边界即让x(next)=0，同理y也有可能越界，因此判断后让y(next) = nums[0].length-1。
- 由左下方方向换成右上方方向行进。按上面，同理再左上方最后一步做完之后，进行边界恢复，即如果x越界x(next)=nums.length-1，y越界让y(next)=0
- 最后是特殊情况。如果x,y同时越界，比如由[0,2]到[1,2]的过程，由于[0,2]会向右上方走，因此x,y会变成[-1,3]，此时不光要把y调整回来，还应让x+2，即当x<0&&y>=nums[0].length时，x[next]=x+2,y=nums[0].length-1；同理在右下方两者都越界时，x[next]=nums.length,y[next]=y+2。这两种情况只有在主对角线上才会出现。

再说子问题，做完原问题的遍历，子问题的思路就清晰了不少，虽然规律不一样，遍历方式也不同，但还是按最先说的，先把路径写出来。我们可以发现子问题实际上就是先以第一行的每一个元素为起点遍历完所在的斜行，再以最后一列每一个元素为起点，遍历没一斜行，具体细节可以看我的代码，规律的思路还是和上面差不多。

